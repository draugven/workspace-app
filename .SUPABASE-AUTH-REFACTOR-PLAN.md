# Supabase Auth Refactor Implementation Plan

## Context & Root Cause

**Problem Identified**: v0.15.0 introduced a critical bug where making the AuthProvider's `.then()` callback `async` and adding `await isUserAdmin()` inside it created a **deadlock**. When the database query hangs (known Supabase bug), the async callback never completes, `.finally()` never runs, and `setLoading(false)` never executes—freezing the UI in an infinite loading state after page refresh.

**Official Supabase Documentation Quote**: *"There is currently a bug in supabase-js which results in a deadlock if any async API call is made in onAuthStateChange code."*

**Current State**:
- On v0.14.0 (commit `a31ecb6`) - working version
- v0.15.0 (commit `80c764f`) contains the broken code (unpushed)
- Investigation branch `investigate/supabase-hanging-promises` preserved with debug code

**Documentation Sources**:
- `.supabase-issue-summary.md` - Our debugging session documentation
- `Supabase Auth Hanging Promises. Best Practices.md` - External consultant's comprehensive analysis with official patterns

---

## Implementation Plan

### Phase 1: Preparation & Documentation (MUST DO FIRST)

#### 1.1 Update CLAUDE.md with Anti-Patterns

Add new section after "Key Technical Solutions" and before "Page-Specific Filter States":

```markdown
## Supabase Auth Anti-Patterns & Best Practices

**CRITICAL: Async Operations in Auth Callbacks Cause Deadlocks**

❌ **NEVER DO THIS:**
```typescript
// This creates a deadlock - promises hang indefinitely
supabase.auth.onAuthStateChange(async (event, session) => {
  await supabase.from('profiles').select('*')  // BLOCKS FOREVER
})

supabase.auth.getSession()
  .then(async ({ session }) => {
    await someAsyncOperation()  // BLOCKS .finally()
  })
  .finally(() => setLoading(false))  // NEVER RUNS
```

✅ **CORRECT PATTERN:**
```typescript
// Keep callbacks synchronous - no async, no await
supabase.auth.onAuthStateChange((event, session) => {
  setUser(session?.user || null)  // Only state updates
})

// Separate auth initialization from supplementary queries
supabase.auth.getSession()
  .then(({ session }) => {
    setUser(session?.user || null)
  })
  .finally(() => setLoading(false))  // Always runs

// Fetch additional data in separate useEffect (non-blocking)
useEffect(() => {
  if (!user) return

  const fetchProfile = async () => {
    const { data } = await supabase.from('profiles').select('*')
    setProfile(data)
  }

  fetchProfile()
}, [user?.id])
```

**Why This Matters:**
- Supabase client locks when auth callbacks contain async operations
- Making callbacks `async` or using `await` inside them creates circular dependencies
- Supplementary queries (roles, profiles) must be fetched separately to avoid blocking initialization
- Official Supabase docs: "Do not use other Supabase functions in the callback function"

**Supabase Client Pattern:**
- **Current**: Singleton `export const supabase = createClient(...)`
- **Official**: Lazy initialization - create clients on-demand with functions
- **Migration**: Low priority optimization (singleton works but not official pattern)

**getUser() vs getSession():**
- **Server-side** (middleware, Server Components): ALWAYS use `getUser()` (validates with auth server)
- **Client-side**: Either works, but `getSession()` is faster (reads localStorage)
- **Security**: Server always enforces authorization with `getUser()`, client is for UX only

**Middleware Requirements:**
- Must call `await supabase.auth.getUser()` to refresh expired tokens
- Pass refreshed tokens to both Server Components (request.cookies) and browser (response.cookies)
- No logic between `createServerClient` and `getUser()` calls
```

#### 1.2 Extract v0.15.0 Improvements to TODO Backlog

**Check what v0.15.0 accomplished** (from git diff between a31ecb6 and 80c764f):
1. Admin status moved to AuthProvider context (instead of individual components calling useAdminCheck)
2. Navigation moved to root layout (eliminates re-mounts)
3. URL redirect preservation after login (saves destination URL, redirects after auth)
4. USER_UPDATED event handler for dynamic admin role changes
5. getSafeRedirectPath() validation (prevents open redirect vulnerabilities)
6. 40 new security tests added
7. Deleted unused useAdminCheck hook (moved logic to AuthProvider)

**Revert to v0.14.0 and add these as TODOs** (because the implementation caused deadlock):

```markdown
## TODO Backlog
1. Auto-archive completed tasks (14-day threshold, `completed_at` + `archived` fields)
2. ~~Persist filter settings to localStorage~~ ✅ COMPLETED (v0.14.0)
3. Consider consolidating localStorage keys per page (optional performance optimization)
4. Fix version history dialog mobile responsiveness
5. Enhance mobile drag-and-drop UX
6. Offline capabilities research
7. **Mitigate localStorage loading "flash"** (theme/filters flash defaults before persisted values load)
8. ~~**Persist current route/page across browser refresh**~~ ✅ COMPLETED (v0.15.0) - REVERTED DUE TO BUG, RE-IMPLEMENT
9. **Improve filter UX - allow collapsing active filters**
10. **Restructure project root directory - reduce clutter** (see PERFORMANCE_ANALYSIS.md)
11. **Admin status in AuthProvider context (non-blocking pattern)** - RE-IMPLEMENT v0.15.0 FEATURE
    - Move admin checks from individual components (useAdminCheck hook) to centralized context
    - CRITICAL: Use separate useEffect, never block auth initialization
    - Reduces database queries by ~75% (single check vs per-component)
    - Must follow official Supabase async callback anti-pattern guidance
12. **Navigation in root layout** - RE-IMPLEMENT v0.15.0 FEATURE
    - Eliminates Navigation re-mounting on route changes
    - Performance improvement (less re-renders)
13. **URL redirect preservation after login** - RE-IMPLEMENT v0.15.0 FEATURE
    - Save destination URL when redirecting to login
    - Redirect to original page after successful authentication
    - Include getSafeRedirectPath() validation to prevent open redirect vulnerabilities
14. **USER_UPDATED event handler for admin role changes** - RE-IMPLEMENT v0.15.0 FEATURE
    - Listen for user metadata changes
    - Dynamically update admin status without requiring re-login
15. **Consider Supabase client pattern migration**
    - Current: Singleton pattern `export const supabase = createClient(...)`
    - Official: Lazy initialization with functions (create on-demand)
    - Low priority - singleton works but not official best practice
16. **Consider app_metadata for admin roles** (future optimization)
    - Current: Database query to `user_roles` table
    - Alternative: Store role in `app_metadata` (set server-side via Auth Admin API)
    - Eliminates database query, reduces latency
17. **Consider JWT claims for roles** (future optimization, most performant)
    - Embed role in JWT via Postgres function hook
    - No database query needed (role in token)
    - Requires custom access token hook in Supabase
18. **Add timeout protection for auth operations** (production resilience)
    - Wrap critical auth calls with Promise.race pattern
    - Recommended: 5s for auth, 10s for profiles, 30s for other queries
    - Prevents edge cases from hanging app indefinitely
```

#### 1.3 Update Current Status in CLAUDE.md

Change version from v0.13.0 to v0.14.0 and update Recent Changes:

```markdown
## Current Status (v0.14.0)
- **Routes**: /props, /tasks, /notes, /admin/invitations, /accept-invite
- **Features**: Invite-only authentication, admin system (app-level), German UI, mobile-responsive, filter persistence, system theme support
- **Authentication**: Token-based invitation system with 7-day expiry, single-use tokens
- **Data**: 105+ theater props imported, character/category color system
- **UI**: Advanced filtering/sorting with localStorage persistence, multi-select components, dark mode (light/dark/system), mobile editor viewport fix
- **Dev Server**: Port 3000
- **Tests**: 129 passing (auth 11, realtime 16, persisted state 26, theme 28, error boundaries 9, API routes 39)

## Recent Changes
- **v0.14.0**: Filter persistence & system theme support - all filters persist to localStorage, system theme with OS detection, usePersistedState hook with SSR safety, 52 new tests (129 total, 100% pass)
- **v0.13.0**: Invite-only authentication system - token-based registration, admin invitation UI, Authorization header pattern, 39 tests (97.97% coverage)
```

---

### Phase 2: Revert to Clean v0.14.0 State

#### 2.1 Ensure All Work is Preserved

```bash
# Verify investigation branch exists and contains all debug code
git log investigate/supabase-hanging-promises --oneline | head -5

# Verify current state (should be on detached HEAD at a31ecb6)
git status
```

#### 2.2 Return to Main Branch at v0.14.0

```bash
# Switch to main branch
git checkout main

# Verify we're at the correct commit
git log --oneline | head -5
# Should show: a31ecb6 feat: implement filter persistence and system theme support (v0.14.0)

# Hard reset to ensure clean state (discards any uncommitted changes from v0.15.0)
git reset --hard a31ecb6
```

#### 2.3 Apply Cherry-Picked Changes

**Note**: These changes from the investigation branch have already been applied:
- ✅ `cleandev` script added to package.json
- ✅ SSR/hydration guidance added to CLAUDE.md Development Guidelines
- ✅ Supabase auth anti-patterns section added to CLAUDE.md

You can delete `.claude-cherry-pick-plan.md` - it's been completed.

#### 2.4 Clean Build Artifacts

```bash
npm run cleandev
```

---

### Phase 3: Implement Core Features with Correct Patterns

**CRITICAL PRINCIPLE**: Never block auth initialization with supplementary queries. Auth state loads fast, additional data loads separately.

#### 3.1 Fix Admin Status Check Pattern

**File**: `src/components/auth/auth-provider.tsx`

**Current Pattern in v0.14.0** (working, individual components call useAdminCheck):
```typescript
// Each component that needs admin check does:
const { isAdmin, loading } = useAdminCheck()
```

**Target Pattern** (centralized, non-blocking):
```typescript
'use client'

import { createContext, useState, useEffect, useContext } from 'react'
import { User } from '@supabase/supabase-js'
import { useRouter } from 'next/navigation'
import { supabase } from '@/lib/supabase'
import { isUserAdmin } from '@/lib/auth-utils'

type AuthContextType = {
  user: User | null
  loading: boolean
  isAdmin: boolean
  adminLoading: boolean
}

const AuthContext = createContext<AuthContextType>({
  user: null,
  loading: true,
  isAdmin: false,
  adminLoading: false,
})

export const useAuth = () => useContext(AuthContext)

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null)
  const [loading, setLoading] = useState(true)
  const [isAdmin, setIsAdmin] = useState(false)
  const [adminLoading, setAdminLoading] = useState(false)
  const router = useRouter()

  useEffect(() => {
    // FAST PATH: Auth initialization only, no async operations
    supabase.auth.getSession()
      .then(({ data: { session } }) => {
        setUser(session?.user ?? null)
      })
      .catch((error) => {
        console.error('[AuthProvider] Error getting session:', error)
      })
      .finally(() => {
        setLoading(false)  // Always runs - never blocked
      })

    // Auth state change listener - SYNCHRONOUS ONLY
    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      (event, session) => {
        console.log('[AuthProvider] Auth state change:', event)
        setUser(session?.user ?? null)

        // NO ASYNC OPERATIONS HERE - will cause deadlock
      }
    )

    return () => subscription.unsubscribe()
  }, [router])

  // SEPARATE EFFECT: Non-blocking admin status fetch
  useEffect(() => {
    if (!user) {
      setIsAdmin(false)
      setAdminLoading(false)
      return
    }

    const fetchAdminStatus = async () => {
      setAdminLoading(true)
      try {
        const adminStatus = await isUserAdmin(user.id)
        setIsAdmin(adminStatus)
      } catch (error) {
        console.error('[AuthProvider] Failed to fetch admin status:', error)
        // Fail gracefully - assume not admin
        setIsAdmin(false)
      } finally {
        setAdminLoading(false)
      }
    }

    fetchAdminStatus()
  }, [user?.id])  // Only re-run when user ID changes

  return (
    <AuthContext.Provider value={{ user, loading, isAdmin, adminLoading }}>
      {children}
    </AuthContext.Provider>
  )
}
```

**Key Changes**:
1. Auth initialization (getSession) stays fast, never blocked
2. Admin check moved to separate useEffect with separate loading state
3. Both onAuthStateChange callback and getSession().then() contain ONLY synchronous state updates
4. If admin check fails/hangs, it doesn't crash auth provider
5. Components can show auth state immediately, admin UI progressively

#### 3.2 Update Components Using useAdminCheck

**Files to update**:
- `src/components/layout/navigation.tsx`
- `src/components/items/item-detail-drawer.tsx`
- `src/components/tasks/task-edit-dialog.tsx`
- `src/components/notes/note-card.tsx`

**Change**:
```typescript
// OLD (v0.14.0)
import { useAdminCheck } from '@/hooks/use-admin-check'
const { isAdmin } = useAdminCheck()

// NEW
import { useAuth } from '@/components/auth/auth-provider'
const { isAdmin, adminLoading } = useAuth()

// Optional: Show loading state for admin UI
{adminLoading ? (
  <Skeleton className="h-8 w-20" />
) : isAdmin && (
  <AdminButton />
)}
```

#### 3.3 Delete useAdminCheck Hook (No Longer Needed)

**File**: `src/hooks/use-admin-check.tsx` - DELETE THIS FILE

The hook is obsolete because admin status is now in centralized AuthProvider context.

#### 3.4 Move Navigation to Root Layout (Performance Optimization)

**File**: `src/app/layout.tsx`

**Current** (Navigation in each page):
```typescript
// Each page imports and renders <Navigation />
```

**Target** (Navigation in root layout):
```typescript
import type { Metadata } from 'next'
import { Inter } from 'next/font/google'
import './globals.css'
import { AuthProvider } from '@/components/auth/auth-provider'
import { ThemeProvider } from '@/components/theme/theme-provider'
import { Navigation } from '@/components/layout/navigation'
import { Footer } from '@/components/layout/footer'

const inter = Inter({ subsets: ['latin'] })

export const metadata: Metadata = {
  title: 'Back2Stage',
  description: 'Theater Production Collaboration Tool',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="de" suppressHydrationWarning>
      <body className={inter.className}>
        <ThemeProvider>
          <AuthProvider>
            <div className="flex min-h-screen flex-col">
              <Navigation />
              <main className="flex-1">{children}</main>
              <Footer />
            </div>
          </AuthProvider>
        </ThemeProvider>
      </body>
    </html>
  )
}
```

**Remove Navigation imports from**:
- `src/app/props/page.tsx`
- `src/app/tasks/page.tsx`
- `src/app/notes/page.tsx`
- `src/app/admin/invitations/page.tsx`

#### 3.5 Add URL Redirect Preservation (Security-First)

**File**: `src/lib/redirect-utils.ts` (NEW FILE)

```typescript
// Utility to validate and sanitize redirect URLs
export function getSafeRedirectPath(url: string | null): string {
  if (!url) return '/'

  try {
    // Parse the URL
    const parsed = new URL(url, 'http://localhost')

    // Only allow relative paths (no external redirects)
    if (parsed.origin !== 'http://localhost') {
      console.warn('[Redirect] Blocked external redirect:', url)
      return '/'
    }

    const path = parsed.pathname + parsed.search

    // Whitelist allowed paths
    const allowedPaths = [
      '/props',
      '/tasks',
      '/notes',
      '/admin/invitations',
    ]

    // Check if path starts with any allowed path
    const isAllowed = allowedPaths.some(allowed => path.startsWith(allowed))

    if (!isAllowed) {
      console.warn('[Redirect] Blocked unauthorized redirect:', path)
      return '/'
    }

    return path
  } catch (error) {
    console.error('[Redirect] Invalid URL:', url, error)
    return '/'
  }
}
```

**File**: `src/components/auth/protected-route.tsx`

**Update to save destination URL**:
```typescript
'use client'

import { useEffect } from 'react'
import { useRouter, usePathname } from 'next/navigation'
import { useAuth } from './auth-provider'

export function ProtectedRoute({ children }: { children: React.ReactNode }) {
  const { user, loading } = useAuth()
  const router = useRouter()
  const pathname = usePathname()

  useEffect(() => {
    if (!loading && !user) {
      // Save current path to localStorage before redirecting
      if (pathname !== '/login') {
        localStorage.setItem('redirectAfterLogin', pathname)
      }
      router.push('/login')
    }
  }, [user, loading, router, pathname])

  if (loading) {
    return <div>Loading...</div>
  }

  if (!user) {
    return null
  }

  return <>{children}</>
}
```

**File**: `src/app/login/page.tsx`

**Update to handle redirect after successful login**:
```typescript
'use client'

import { useState, useEffect } from 'react'
import { useRouter } from 'next/navigation'
import { supabase } from '@/lib/supabase'
import { useAuth } from '@/components/auth/auth-provider'
import { getSafeRedirectPath } from '@/lib/redirect-utils'
import { LoginForm } from '@/components/auth/login-form'
// ... other imports

export default function LoginPage() {
  const { user, loading } = useAuth()
  const router = useRouter()
  const [mounted, setMounted] = useState(false)

  useEffect(() => {
    setMounted(true)
  }, [])

  useEffect(() => {
    if (!loading && user) {
      // Get saved redirect path
      const savedPath = localStorage.getItem('redirectAfterLogin')
      localStorage.removeItem('redirectAfterLogin')

      // Validate and redirect
      const safePath = getSafeRedirectPath(savedPath)
      router.push(safePath)
    }
  }, [user, loading, router])

  // ... rest of component
}
```

#### 3.6 Add USER_UPDATED Event Handler

**File**: `src/components/auth/auth-provider.tsx`

**Update onAuthStateChange**:
```typescript
const { data: { subscription } } = supabase.auth.onAuthStateChange(
  (event, session) => {
    console.log('[AuthProvider] Auth state change:', event)

    // Update user state
    setUser(session?.user ?? null)

    // Handle specific events
    if (event === 'SIGNED_OUT') {
      setIsAdmin(false)
      setAdminLoading(false)
    }

    // USER_UPDATED fires when user metadata changes
    // This allows dynamic admin role updates without re-login
    if (event === 'USER_UPDATED' && session?.user) {
      console.log('[AuthProvider] User updated, refreshing admin status')
      // Trigger admin status re-fetch by updating user state
      // (The separate useEffect watching user.id will re-run)
    }
  }
)
```

**Why This Works**:
- USER_UPDATED event fires when admin modifies user metadata
- We only update user state (synchronous operation)
- The separate useEffect watching `user?.id` automatically re-fetches admin status
- No async operations in callback = no deadlock

---

### Phase 4: Testing & Validation

#### 4.1 Update Existing Tests

**File**: `src/components/auth/__tests__/auth-provider.test.tsx`

Update tests to expect new context shape:
```typescript
// Test should verify non-blocking admin check
it('fetches admin status separately from auth initialization', async () => {
  const { result } = renderHook(() => useAuth(), { wrapper })

  // Auth should complete first (loading: false)
  await waitFor(() => {
    expect(result.current.loading).toBe(false)
    expect(result.current.user).toBeTruthy()
  })

  // Admin check still loading
  expect(result.current.adminLoading).toBe(true)

  // Then admin check completes
  await waitFor(() => {
    expect(result.current.adminLoading).toBe(false)
    expect(result.current.isAdmin).toBe(true)
  })
})
```

#### 4.2 Add New Tests for Async Anti-Pattern Protection

**File**: `src/components/auth/__tests__/auth-provider-deadlock-prevention.test.tsx` (NEW)

```typescript
import { renderHook, waitFor } from '@testing-library/react'
import { useAuth, AuthProvider } from '../auth-provider'
import { supabase } from '@/lib/supabase'

// Mock Supabase to simulate hanging query
jest.mock('@/lib/supabase', () => ({
  supabase: {
    auth: {
      getSession: jest.fn(),
      onAuthStateChange: jest.fn(),
    },
    from: jest.fn(),
  },
}))

describe('AuthProvider Deadlock Prevention', () => {
  it('should not block auth initialization if admin query hangs', async () => {
    // Mock successful auth
    ;(supabase.auth.getSession as jest.Mock).mockResolvedValue({
      data: { session: { user: { id: '123', email: 'test@test.com' } } },
      error: null,
    })

    // Mock hanging admin query (never resolves)
    const hangingPromise = new Promise(() => {})
    ;(supabase.from as jest.Mock).mockReturnValue({
      select: jest.fn().mockReturnValue({
        eq: jest.fn().mockReturnValue({
          single: jest.fn().mockReturnValue(hangingPromise),
        }),
      }),
    })

    const wrapper = ({ children }: { children: React.ReactNode }) => (
      <AuthProvider>{children}</AuthProvider>
    )

    const { result } = renderHook(() => useAuth(), { wrapper })

    // Auth should complete despite hanging admin query
    await waitFor(() => {
      expect(result.current.loading).toBe(false)
      expect(result.current.user).toBeTruthy()
    }, { timeout: 3000 })

    // Admin check still loading (but doesn't block)
    expect(result.current.adminLoading).toBe(true)
    expect(result.current.isAdmin).toBe(false)
  })
})
```

#### 4.3 Run Full Test Suite

```bash
npm test -- --coverage
```

**Expected**: All existing tests pass, new tests validate non-blocking pattern.

#### 4.4 Manual Testing Checklist

**Test Scenarios**:
1. ✅ Fresh login → data loads immediately
2. ✅ Page refresh (Cmd+R) → no hanging, data loads
3. ✅ Hard refresh (Cmd+Shift+R) → no hanging, data loads
4. ✅ Navigate between routes → Navigation doesn't re-mount
5. ✅ Login from /props → redirects back to /props after auth
6. ✅ Login from /admin/invitations → validates allowed path, redirects
7. ✅ Attempt redirect to external URL → blocked, redirects to /
8. ✅ Admin UI shows/hides based on role
9. ✅ Non-admin user can't see admin buttons
10. ✅ Network throttling (slow 3G) → app still functional, no indefinite hangs

**How to Test Hanging Fix**:
1. Login as admin
2. Navigate to /props
3. Open DevTools Network tab
4. Simulate slow network: DevTools → Network → Throttling → Slow 3G
5. Hard refresh (Cmd+Shift+R)
6. **Expected**: Page loads within 10-15 seconds, no infinite "Loading..."
7. **Before Fix**: Would hang indefinitely showing "Items werden geladen"

---

### Phase 5: Commit & Version Bump

#### 5.1 Update Version Numbers

**File**: `package.json`
```json
{
  "version": "0.15.0",
  ...
}
```

**File**: `CLAUDE.md` - Update "Current Status" and "Recent Changes"

```markdown
## Current Status (v0.15.0)
- **Routes**: /props, /tasks, /notes, /admin/invitations, /accept-invite
- **Features**: Invite-only authentication, centralized admin context (non-blocking), URL redirect preservation, system theme support, filter persistence
- **Authentication**: Token-based invitation with redirect after login, dynamic admin role updates
- **Performance**: Navigation in root layout (eliminates re-mounts), centralized admin checks (75% fewer DB queries)
- **Tests**: 145+ passing (includes new deadlock prevention tests)
- **Dev Server**: Port 3000

## Recent Changes
- **v0.15.0**: Auth & navigation optimizations (FIXED) - centralized admin status in AuthProvider with non-blocking pattern (follows Supabase async callback anti-pattern guidance), URL redirect preservation with security validation (getSafeRedirectPath), Navigation moved to root layout (performance), USER_UPDATED event handler for dynamic role changes, comprehensive async deadlock prevention tests, removed useAdminCheck hook
- **v0.14.0**: Filter persistence & system theme support - localStorage persistence, system theme with OS detection, usePersistedState hook, 52 new tests
- **v0.13.0**: Invite-only authentication - token-based registration, admin invitation UI, 39 tests
```

#### 5.2 Commit Changes

```bash
# Stage all changes
git add .

# Commit with detailed message
git commit -m "$(cat <<'EOF'
feat: implement auth & navigation optimizations with non-blocking pattern (v0.15.0)

BREAKING FIX: Resolved critical Supabase auth deadlock bug

- Moved admin status checks to separate useEffect (non-blocking pattern)
- Follows official Supabase guidance: no async operations in auth callbacks
- Auth initialization completes fast, supplementary queries load separately
- Prevents indefinite hanging on page refresh

Features:
- Admin status centralized in AuthProvider context (75% reduction in DB queries)
- Navigation moved to root layout (eliminates re-mounting on route changes)
- URL redirect preservation after login with security validation
- getSafeRedirectPath() prevents open redirect vulnerabilities
- USER_UPDATED event handler for dynamic admin role changes

Tests:
- Added deadlock prevention test suite
- Verified non-blocking admin status fetch
- All 145+ tests passing

Documentation:
- Added Supabase async callback anti-patterns to CLAUDE.md
- Documented correct patterns for auth initialization
- Updated TODO backlog with future optimizations

🤖 Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>
EOF
)"
```

#### 5.3 Verify Clean State

```bash
# Check status
git status

# View commit
git log --oneline -1

# Run dev server
npm run cleandev
```

---

## Implementation Sequence Summary

**MUST FOLLOW THIS EXACT ORDER**:

1. ✅ Update CLAUDE.md with anti-patterns section (DONE)
2. ✅ Extract v0.15.0 improvements to TODO backlog (DONE)
3. ✅ Update Current Status to v0.14.0 (DONE)
4. ✅ Apply cherry-picked changes from investigation branch (cleandev script, SSR guidance) (DONE)
5. Revert to main at commit a31ecb6 (git checkout main && git reset --hard a31ecb6)
6. Implement non-blocking admin check in AuthProvider (two separate useEffects)
7. Update components using useAdminCheck to use useAuth()
8. Delete src/hooks/use-admin-check.tsx
9. Move Navigation to root layout
10. Remove Navigation from individual pages
11. Create redirect-utils.ts with getSafeRedirectPath()
12. Update ProtectedRoute to save destination URL
13. Update LoginPage to redirect after auth
14. Add USER_UPDATED handler to AuthProvider
15. Update existing tests
16. Add new deadlock prevention tests
17. Run full test suite (npm test -- --coverage)
18. Manual testing with network throttling
19. Update version to 0.15.0 in package.json
20. Update Current Status and Recent Changes in CLAUDE.md
21. Commit with detailed message
22. Run npm run cleandev and verify

---

## Critical Success Criteria

**The implementation is complete when**:
1. Page refresh (Cmd+R) does NOT hang - data loads within seconds
2. Auth initialization completes before admin status check
3. Failed admin queries don't block UI from rendering
4. Navigation doesn't re-mount on route changes
5. Login redirects to original destination (if allowed path)
6. External redirect attempts are blocked
7. All tests pass (145+)
8. Manual testing confirms no regressions

**If anything hangs or breaks**:
- Immediately check if async operations are in auth callbacks
- Verify admin check is in separate useEffect with separate loading state
- Check console for "[AuthProvider]" debug logs
- Test with network throttling to simulate slow queries

---

## Post-Implementation: Future Optimizations (Low Priority)

**After v0.15.0 is stable**, consider:

1. **Migrate to lazy Supabase client initialization** (official pattern)
2. **Move admin roles to app_metadata** (eliminates DB query)
3. **Implement JWT claims for roles** (most performant, no queries)
4. **Add timeout protection with Promise.race** (5s auth, 10s profiles)
5. **Add error boundaries for auth failures** (graceful degradation)
6. **Implement middleware for route protection** (server-side validation)

These are documented in TODO backlog items #15-18.
