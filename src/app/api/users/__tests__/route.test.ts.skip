import { GET } from '../route'
import { NextRequest } from 'next/server'

// Mock Supabase admin client
const mockGetUser = jest.fn()
const mockListUsers = jest.fn()

jest.mock('@supabase/supabase-js', () => ({
  createClient: jest.fn(() => ({
    auth: {
      getUser: mockGetUser,
      admin: {
        listUsers: mockListUsers,
      },
    },
  })),
}))

describe('/api/users', () => {
  beforeEach(() => {
    jest.clearAllMocks()
  })

  afterEach(() => {
    jest.restoreAllMocks()
  })

  describe('Authentication', () => {
    it('returns 401 when no Authorization header is provided', async () => {
      const request = new NextRequest('http://localhost:3000/api/users')

      const response = await GET(request)
      const data = await response.json()

      expect(response.status).toBe(401)
      expect(data.error).toBe('Unauthorized')
      expect(mockListUsers).not.toHaveBeenCalled()
    })

    it('returns 401 when token is invalid', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: null },
        error: new Error('Invalid token'),
      })

      const request = new NextRequest('http://localhost:3000/api/users', {
        headers: {
          Authorization: 'Bearer invalid-token',
        },
      })

      const response = await GET(request)
      const data = await response.json()

      expect(response.status).toBe(401)
      expect(data.error).toBe('Invalid or expired token')
      expect(mockListUsers).not.toHaveBeenCalled()
    })

    it('returns 401 when token is expired', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: null },
        error: null,
      })

      const request = new NextRequest('http://localhost:3000/api/users', {
        headers: {
          Authorization: 'Bearer expired-token',
        },
      })

      const response = await GET(request)
      const data = await response.json()

      expect(response.status).toBe(401)
      expect(data.error).toBe('Invalid or expired token')
    })
  })

  describe('Successful Requests', () => {
    it('returns user list when authenticated', async () => {
      const mockUser = { id: 'user-123', email: 'test@example.com' }
      const mockUsers = [
        {
          id: 'user-1',
          email: 'user1@example.com',
          user_metadata: { full_name: 'User One' },
          created_at: '2024-01-01',
        },
        {
          id: 'user-2',
          email: 'user2@example.com',
          user_metadata: {},
          created_at: '2024-01-02',
        },
      ]

      mockGetUser.mockResolvedValue({
        data: { user: mockUser },
        error: null,
      })

      mockListUsers.mockResolvedValue({
        data: { users: mockUsers },
        error: null,
      })

      const request = new NextRequest('http://localhost:3000/api/users', {
        headers: {
          Authorization: 'Bearer valid-token',
        },
      })

      const response = await GET(request)
      const data = await response.json()

      expect(response.status).toBe(200)
      expect(data).toHaveLength(2)
      expect(data[0]).toEqual({
        id: 'user-1',
        email: 'user1@example.com',
        full_name: 'User One',
        created_at: '2024-01-01',
      })
      expect(data[1]).toEqual({
        id: 'user-2',
        email: 'user2@example.com',
        full_name: 'user2@example.com', // Falls back to email
        created_at: '2024-01-02',
      })
    })

    it('filters sensitive user data', async () => {
      const mockUser = { id: 'user-123', email: 'test@example.com' }
      const mockUsers = [
        {
          id: 'user-1',
          email: 'user1@example.com',
          user_metadata: { full_name: 'User One' },
          created_at: '2024-01-01',
          // Sensitive fields that should not be returned
          encrypted_password: 'hashed-password',
          phone: '+1234567890',
          app_metadata: { provider: 'email' },
        },
      ]

      mockGetUser.mockResolvedValue({
        data: { user: mockUser },
        error: null,
      })

      mockListUsers.mockResolvedValue({
        data: { users: mockUsers },
        error: null,
      })

      const request = new NextRequest('http://localhost:3000/api/users', {
        headers: {
          Authorization: 'Bearer valid-token',
        },
      })

      const response = await GET(request)
      const data = await response.json()

      expect(response.status).toBe(200)
      expect(data[0]).toEqual({
        id: 'user-1',
        email: 'user1@example.com',
        full_name: 'User One',
        created_at: '2024-01-01',
      })
      // Verify sensitive fields are not included
      expect(data[0]).not.toHaveProperty('encrypted_password')
      expect(data[0]).not.toHaveProperty('phone')
      expect(data[0]).not.toHaveProperty('app_metadata')
    })
  })

  describe('Error Handling', () => {
    it('returns 500 when listUsers fails', async () => {
      const mockUser = { id: 'user-123', email: 'test@example.com' }
      const consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation()

      mockGetUser.mockResolvedValue({
        data: { user: mockUser },
        error: null,
      })

      mockListUsers.mockResolvedValue({
        data: { users: [] },
        error: new Error('Database error'),
      })

      const request = new NextRequest('http://localhost:3000/api/users', {
        headers: {
          Authorization: 'Bearer valid-token',
        },
      })

      const response = await GET(request)
      const data = await response.json()

      expect(response.status).toBe(500)
      expect(data.error).toBe('Failed to fetch users')
      expect(consoleErrorSpy).toHaveBeenCalledWith(
        'Error fetching users:',
        expect.any(Error)
      )

      consoleErrorSpy.mockRestore()
    })

    it('returns 500 on unexpected server error', async () => {
      const consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation()

      mockGetUser.mockRejectedValue(new Error('Unexpected error'))

      const request = new NextRequest('http://localhost:3000/api/users', {
        headers: {
          Authorization: 'Bearer valid-token',
        },
      })

      const response = await GET(request)
      const data = await response.json()

      expect(response.status).toBe(500)
      expect(data.error).toBe('Internal server error')
      expect(consoleErrorSpy).toHaveBeenCalledWith(
        'Server error fetching users:',
        expect.any(Error)
      )

      consoleErrorSpy.mockRestore()
    })
  })

  describe('Token Handling', () => {
    it('properly strips "Bearer " prefix from token', async () => {
      const mockUser = { id: 'user-123', email: 'test@example.com' }

      mockGetUser.mockResolvedValue({
        data: { user: mockUser },
        error: null,
      })

      mockListUsers.mockResolvedValue({
        data: { users: [] },
        error: null,
      })

      const request = new NextRequest('http://localhost:3000/api/users', {
        headers: {
          Authorization: 'Bearer my-token-123',
        },
      })

      await GET(request)

      expect(mockGetUser).toHaveBeenCalledWith('my-token-123')
    })
  })
})
